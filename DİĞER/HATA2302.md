
# Randevu Oluşturma API Entegrasyonu Sorun Çözümü ve Yol Haritası

## 1. Tespit Edilen Sorun

Randevu oluşturma işleminde "createAppointment() from the server but createAppointment is on the client" hata mesajı alınıyordu. Bu, Next.js'in istemci/sunucu sınırlarının ihlal edildiğini gösteren tipik bir hatadır.

## 2. Sorunun Teknik Analizi

Sorunu analiz ettiğimizde şu yapısal problemleri tespit ettik:

1. **İstemci/Sunucu Karışımı**: İstemci tarafı fonksiyonlar (`appointmentService.ts` içindeki `createAppointment`) sunucu tarafından (`/api/mcp/route.ts`) doğrudan çağrılmaya çalışılıyordu.

2. **Tutarsız API Yapısı**: Randevu silme işlemi için sunucu tarafında `deleteAppointmentFromDb` gibi özel bir fonksiyon kullanılırken, randevu oluşturma işlemi için benzer bir yaklaşım yoktu.

3. **Katman İhlali**: MCP API endpoint'inden (`/api/mcp/route.ts`), istemci tarafı fonksiyonları (`mcpTools.createAppointment`) doğrudan çağrılıyordu.

## 3. Çözüm Adımları

Sorunu çözmek için şu adımları takip ettik:

1. **Sunucu Taraflı Randevu Oluşturma Fonksiyonu Ekleme**:
   - `/src/lib/appointment-service/index.js` dosyasına `createAppointmentInDb` fonksiyonu ekledik.
   - Bu fonksiyon, veritabanına doğrudan erişerek randevu oluşturma işlemini gerçekleştiriyor.

2. **API Endpoint'ini Düzenleme**:
   - `/src/app/api/mcp/route.ts` dosyasındaki `create-appointment` handler'ını düzenledik.
   - İstemci taraflı `mcpTools.createAppointment` yerine sunucu taraflı `createAppointmentInDb` fonksiyonunu çağıracak şekilde değiştirdik.

3. **Sınırları Netleştirme**:
   - Sunucu tarafında veritabanı işlemleri yapan fonksiyonlar, istemci tarafında UI ile etkileşimi yöneten fonksiyonlar arasındaki sınırı netleştirdik.

## 4. Merkezi ve Dengeli Yapıya Uyum

Çözümümüz, projenin hedeflediği merkezi ve üç katmanlı mimariye tam olarak uyum sağlamaktadır:

1. **Formatlama Katmanı** (`/utils/appointment/formatters.ts`):
   - Veri formatlamaları (tarih, durum, vb.)
   - Doğrulama işlevleri
   - Veri normalizasyon işlevleri

2. **Servis Katmanı**:
   - İstemci: `/services/appointmentService.ts` - API çağrıları
   - Sunucu: `/lib/appointment-service/index.js` - Veritabanı işlemleri
   - Api: `/services/api/apiService.ts` - Merkezi API entegrasyonu

3. **Hook Katmanı** (`/hooks/useAppointmentManagement.ts`):
   - UI state yönetimi
   - Form işleme mantığı
   - Kullanıcı etkileşimleri
   - Servis çağrıları

## 5. Benzer Sorunlar İçin Gelecek Yol Haritası

Next.js projelerinde istemci/sunucu sınırı sorunlarını çözmek için şu adımları takip edin:

1. **İstemci/Sunucu Ayrımını Net Yapın**:
   - İstemci tarafı kodları ('use client' direktifi ile) `/services/` ve `/hooks/` altında tutun
   - Sunucu tarafı kodları `/lib/` ve `/app/api/` altında tutun

2. **Her API Endpoint'i İçin İki Yönlü Servis Oluşturun**:
   - İstemci servis: UI ile etkileşim için (`xxxService.ts`)
   - Sunucu servis: Veritabanı işlemleri için (`xxx-service/index.js`)

3. **API Çağrı Zincirini Standartlaştırın**:
   ```
   UI → Hook → İstemci Servis → ApiService → API Endpoint → Sunucu Servis → Veritabanı
   ```

4. **Yeni Bir Endpoint Eklerken**:
   - Önce sunucu tarafı servis fonksiyonunu oluşturun
   - API endpoint'ini bu fonksiyonu çağıracak şekilde yapılandırın
   - İstemci servisini ve hook'u buna göre güncelleyin

## 6. İyi Uygulamalar

1. **Her API İşlemi İçin Üç Katmanlı Yapı Kullanın**:
   - Formatlama: `/utils/[modül]/formatters.ts`
   - Servis: 
     - İstemci: `/services/[modül]Service.ts`
     - Sunucu: `/lib/[modül]-service/index.js`
   - Hook: `/hooks/use[Modül]Management.ts`

2. **Tutarlı Hata Yönetimi**:
   - Her API yanıtını `{ success, data, error }` formatında standartlaştırın
   - Sunucu tarafı servislerden her zaman bu formatta yanıt döndürün
   - İstemci tarafında try/catch bloklarıyla hataları yakalayın

3. **Tip Güvenliği Sağlayın**:
   - Tüm modüller için TypeScript interface'leri tanımlayın
   - API istek ve yanıt tiplerini önceden tanımlayın

4. **Önbelleğe Alma Mekanizması Ekleyin**:
   - Sık kullanılan veriler için önbelleğe alma stratejisi belirleyin
   - Önbellek anahtarını parametrelere göre oluşturun
   - Veri değişikliklerinde önbelleği geçersiz kılın

Bu yol haritası, projenizde merkezi ve dengeli bir mimariye geçiş sürecinde karşılaşılabilecek benzer sorunların çözümünde rehber olacaktır.


-----


# "Yeni Hizmet" Modalındaki Müşteri Bilgisi Hatası ve Çözümü

## Tespit Edilen Sorun

"Yeni Hizmet" modalı açıldığında "Müşteri bilgisi alınamadı" hatası oluşuyordu. Bu hata, istemci/sunucu sınırlarının ihlal edilmesi nedeniyle ortaya çıkıyordu.

### Sorunun Teknik Detayları

1. **Sınır İhlali**: İstemci kodunda (modallar, bileşenler) doğrudan sunucu tarafı fonksiyonları çağırılıyordu:
   ```javascript
   // HATALI YAKLAŞIM
   export const fetchCustomerDetailsMcpWrapper = async (customerId) => {
     // Doğrudan sunucu tarafı kodu çağrılıyor
     const result = await getCustomerById(customerId);
     ...
   }
   ```

2. **Etkilenen Dosyalar**:
   - `src/components/appointments/NewAppointmentModal/services/mcp-api.ts`
   - İçindeki fonksiyonlar: `fetchCustomerDetailsMcpWrapper`, `fetchStaffDetailsMcpWrapper`

3. **Hata Mesajı**: "MCP müşteri detay getirme hatası: Error: Müşteri bilgisi alınamadı"

4. **Kök Neden**: Modal açılışında müşteri bilgilerini getirmek için kullanılan kod, doğrudan `/lib/mcp/customers` modülündeki sunucu tarafı fonksiyonları çağrıyordu. Next.js'de istemci tarafından sunucu tarafı kodlar doğrudan çağrılamaz.

## Uygulanan Çözüm

Sorunu çözmek için, sunucu tarafı fonksiyon çağrılarını HTTP API çağrılarıyla değiştirdik:

```javascript
// DOĞRU YAKLAŞIM
export const fetchCustomerDetailsMcpWrapper = async (customerId) => {
  try {
    // Sunucu tarafı kodu yerine API çağrısı yapılıyor
    const response = await fetch('/api/mcp', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        method: 'call_tool',
        params: {
          name: 'get-customer-by-id',
          arguments: { id: customerId }
        }
      })
    });

    const result = await response.json();
    if (!result.success) {
      throw new Error(result.error || "Müşteri bilgisi alınamadı");
    }
    
    return result.data;
  } catch (err) {
    console.error("MCP müşteri detay getirme hatası:", err);
    throw new Error("Müşteri bilgisi alınamadı");
  }
};
```

### Yapılan Değişiklikler

1. **Doğrudan API Çağrıları**: 
   - `getCustomerById`, `getStaffById` gibi sunucu tarafı fonksiyonlar yerine, `fetch` ile API endpoint'lerine istek yapıldı
   
2. **Import Düzenlemeleri**:
   - Sunucu tarafı modüllerinin import edilmesi engellendi
   - Yalnızca istemci tarafında kullanılabilecek modüller import edildi

3. **Veri Akışı**:
   - İstemci bileşeni → API çağrısı → API endpoint → Sunucu servisi → Veritabanı
   - Bu akış, merkezi sistem yapısını korudu

## Merkezi API Sistemi ve Doğru Yaklaşım

Bu çözüm, projenizin merkezi API sistemini bozmak yerine **doğru şekilde kullanmayı sağlar**.

### Doğru Merkezi API Yaklaşımı

```
İstemci Bileşenler → Hooks → İstemci Servisleri → ApiService → callMcpApi → API Endpoint → Sunucu Servisleri → Veritabanı
```

Her şeyi düzeltmenin ideal yolu, tüm API çağrılarını merkezi `ApiService` üzerinden yapmaktır:

```javascript
// EN İDEAL YAKLAŞIM
export const fetchCustomerDetailsMcpWrapper = async (customerId) => {
  try {
    // Merkezi ApiService kullanımı
    const result = await ApiService.customers.getById(customerId);
    if (!result.success) {
      throw new Error(result.error || "Müşteri bilgisi alınamadı");
    }
    return result.data;
  } catch (err) {
    console.error("Müşteri detayı getirme hatası:", err);
    throw new Error("Müşteri bilgisi alınamadı");
  }
};
```

## Yol Gösterici İlkeler

Bu tür hataları önlemek için şu ilkeleri takip edin:

1. **İstemci/Sunucu Sınırlarına Dikkat Edin**:
   - İstemci kodunda (`use client` ile işaretli) asla doğrudan `/lib/` altındaki sunucu tarafı fonksiyonları çağırmayın
   - Her zaman HTTP API çağrıları yapın

2. **Merkezi API Servisini Kullanın**:
   - Tüm API çağrılarını `ApiService` üzerinden yapın
   - Başka bir yaklaşım gerekiyorsa, en azından `callMcpApi` fonksiyonunu kullanın

3. **API Çağrı Zincirini Takip Edin**:
   ```
   Bileşen → Hook → ApiService → API Endpoint → Sunucu Servisi → Veritabanı
   ```

4. **Yeni Bir İşlev Eklerken**:
   - Önce sunucu tarafı servisi oluşturun
   - Sonra API endpoint'inde bu servisi çağırın
   - En son istemci tarafı servisi ve hook'u güncelleyin

Bu yaklaşımı takip ederek, tüm projede tutarlı bir API yapısı oluşturabilir ve istemci/sunucu sınırı hatalarından kaçınabilirsiniz.


------